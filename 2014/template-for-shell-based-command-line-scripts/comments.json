[{"id":"dsq-1419626555","author":"Thiago Jung Bauermann","deleted":false,"createdAt":"2014-06-04T18:50:58Z","message":"<p>I recently switched to write Python scripts for tasks where I'd previously write shell scripts. A lot of shell scripts grow in time and you end up needing to do things like manipulate lists or arrays and that is much more pleasant to do in Python than in shell (for me, at least). The subprocess module makes it easy to call commands so it's worth it. I don't write shell scripts anymore. And you get acess the full breadth of Python modules so it's quite powerful. For command line parsing you can use the argparse module, for instance.</p>","replies":[{"id":"dsq-1420511276","author":"Aurélien Gâteau","deleted":false,"createdAt":"2014-06-05T07:07:50Z","message":"<p>What often happens on my side is I start writing a script using shell, but then it grows up to a point where it makes more sense to rewrite it in Python. Having said so, I find myself more efficient with shell for small things, in particular I find piping commands together to be much easier with shell. I am not fond of the subprocess module, which I find quite cumbersome to use.</p>","replies":[]}]},{"id":"dsq-1419673581","author":"Jan Schnackenberg","deleted":false,"createdAt":"2014-06-04T19:18:56Z","message":"<p>This article hit right at home with me. I have a similar loop-structure as my template, but your's covers some aspects that mine doesn't (yet ;) ).</p><p>I feel the need to point out one problem in your sample-code for bash-arrays, though. You explicitly mention them to be able to handle parameters with whitespace in them. Your eval-code ruins that use-case though.</p><p>A short example:</p><p>&gt; VAL1=\"a\"<br>&gt; VAL2=\"b and c\"<br>&gt; VAL3=\"d\"<br>&gt; VAL_ARR=()<br>&gt; echo \"#VAL_ARR=\\\"${#VAL_ARR[@]}\\\"   \"; for I in \"${!VAL_ARR[@]}\"; do echo -n \"${I}: \\\"${VAL_ARR[${I}]}\\\"   \"; done; echo<br>#VAL_ARR=\"0\"</p><p>&gt; VAL_ARR=(${VAL_ARR[@]} \"${VAL1}\")<br>&gt; echo \"#VAL_ARR=\\\"${#VAL_ARR[@]}\\\"   \"; for I in \"${!VAL_ARR[@]}\"; do echo -n \"${I}: \\\"${VAL_ARR[${I}]}\\\"   \"; done; echo<br>#VAL_ARR=\"1\"<br>0: \"a\"</p><p>&gt; VAL_ARR=(${VAL_ARR[@]} \"${VAL2}\")<br>&gt; echo \"#VAL_ARR=\\\"${#VAL_ARR[@]}\\\"   \"; for I in \"${!VAL_ARR[@]}\"; do echo -n \"${I}: \\\"${VAL_ARR[${I}]}\\\"   \"; done; echo                                                                                                                                 <br>#VAL_ARR=\"2\" <br>0: \"a\"   1: \"b and c\"</p><p>&gt; VAL_ARR=(${VAL_ARR[@]} \"${VAL3}\")<br>&gt; echo \"#VAL_ARR=\\\"${#VAL_ARR[@]}\\\"   \"; for I in \"${!VAL_ARR[@]}\"; do echo -n \"${I}: \\\"${VAL_ARR[${I}]}\\\"   \"; done; echo                                                                                                                                 <br>#VAL_ARR=\"5\"   <br>0: \"a\"   1: \"b\"   2: \"and\"   3: \"c\"   4: \"d\"</p><p>You can see, that the array now contains 5 instead of 3 entries. If you enclose the array in double quotes when appending to it, this does not happen:</p><p>&gt; VAL_ARR=( \"${VAL_ARR[@]}\" \"${VAL3}\" )</p>","replies":[{"id":"dsq-1420516144","author":"Aurélien Gâteau","deleted":false,"createdAt":"2014-06-05T07:15:29Z","message":"<p>Ah good point, I forgot quotes around the arguments of the for loop at the end. The complete working example is here: <a href=\"https://gist.github.com/agateau/dcb50a8eb690a2fb9c65\" rel=\"nofollow noopener\" title=\"https://gist.github.com/agateau/dcb50a8eb690a2fb9c65\">https://gist.github.com/aga...</a></p>","replies":[{"id":"dsq-1420558680","author":"Jan Schnackenberg","deleted":false,"createdAt":"2014-06-05T08:13:36Z","message":"<p>That is still missing the double-quotes around the array-part of the assignment in line 50.</p><p>If you change<br>    args=(${args[@]} \"$1\")<br>to<br>  args=( \"${args[@]}\" \"$1\" )<br>then array-elements with blanks wont be split up into multiple elements.</p><p>Your version is able to put those elements into the array ok. But if there is even just one argument added after that, the element with blanks will be split up.</p>","replies":[{"id":"dsq-1420623871","author":"Aurélien Gâteau","deleted":false,"createdAt":"2014-06-05T09:35:01Z","message":"<p>Oh right. I only tested with the last element containing spaces. Updating again. Thanks!</p>","replies":[]}]}]}]},{"id":"dsq-1420179449","author":"Anonymous 2358","deleted":false,"createdAt":"2014-06-05T00:41:09Z","message":"<p>Option parsing boilerplate is so common that Bash now has its own built-in command, <strong>getopts</strong>, to compensate (not to be confused with the standalone <strong>getopt</strong> binary). See <em>man bash</em>.</p>","replies":[{"id":"dsq-1420520569","author":"Aurélien Gâteau","deleted":false,"createdAt":"2014-06-05T07:21:21Z","message":"<p>The problem with getopts is that it does not support long options (\"--foo\"). This is a major drawback for me because I find it easier to read a script which uses long options.</p>","replies":[]},{"id":"dsq-1420556057","author":"Jan Schnackenberg","deleted":false,"createdAt":"2014-06-05T08:09:12Z","message":"<p>While the getopts command does provide a good way to ease the parameter handling, the bash version does not handle long options at all. This is, for my use cases, a deal-breaker. So unless I'd start using ksh93 (nope, not gonna happen) I won't use getopts.</p>","replies":[]}]},{"id":"dsq-1420560405","author":"Jani Uusitalo","deleted":false,"createdAt":"2014-06-05T08:16:32Z","message":"<p>Excellent. Which license would you apply to this? I store many of my small scripts in my personal (but publicly readable) wiki, so I'd like to get the license right for any derivatives I might publish.</p>","replies":[{"id":"dsq-1420623104","author":"Aurélien Gâteau","deleted":false,"createdAt":"2014-06-05T09:33:45Z","message":"<p>It's simple enough that I am going to place it under public domain.</p>","replies":[{"id":"dsq-1420644414","author":"Jani Uusitalo","deleted":false,"createdAt":"2014-06-05T10:02:28Z","message":"<p>Great, thanks!</p>","replies":[]}]}]},{"id":"dsq-1420733227","author":"anonymity is great","deleted":false,"createdAt":"2014-06-05T11:50:24Z","message":"<p>I have been using almost exactly the same way of dealing with options in my scripts. It is actually possible to support separating option arguments with an equal sign: in your --output example, just add the case (separately from the existing -o case which remains):</p><p>--output=*)<br>    output=\"${1#--output=}\"<br>    shift<br>    ;;</p><p>Note that \"${1#--output=}\" is equivalent to `echo \"$1\" | sed -e \"s/^--output=//\"` (according to \"man sh\" in Kubuntu) but faster since it uses a built-in shell construct.</p><p>One could also handle multiple long options together as follows:</p><p>--output=*|--logfile=*)<br>    var=`echo \"$1\" | sed -r 's/^--([^=]*)=.*/\\1/'`<br>    vartransform=\"s/--${var}=//\"<br>    eval \"${var}=`echo \\\"$1\\\" | sed -e $vartransform`\"</p><p>and later use ${output} and ${logfile}.</p><p>(Hopefully the blog's software keeps the spaces so that the above code remains readable.)</p>","replies":[{"id":"dsq-1420741207","author":"Aurélien Gâteau","deleted":false,"createdAt":"2014-06-05T11:58:08Z","message":"<p>Thanks for sharing, though I would find it a bit cumbersome to write this for all options. The way to handle multiple long options looks efficient, but a bit scary to read :)</p>","replies":[{"id":"dsq-1422450909","author":"anonymity is great","deleted":false,"createdAt":"2014-06-06T11:46:17Z","message":"<p>I know ;-) Actually the code is only efficient for writing, it is not efficient in the sense of performance of the script because for each option two sed commands must be run. A faster way to do the same is (still unreadable):</p><p>   --output=*|--logfile=*)<br>var=\"${1#--}\"<br>var=\"${var%%=*}\"<br>eval \"${var}=\\\"${1#--${var}=}\\\"\"</p><p>On my machine, running</p><p>time for ((i = 1; i &lt;= 100; i++)); do ./myscript --output=qdsf --logfile=jkml; done</p><p>shows that the new version is much faster than the old version.</p>","replies":[]}]}]},{"id":"dsq-1449563630","author":"ddevine","deleted":false,"createdAt":"2014-06-23T07:24:56Z","message":"<p>Very cool, bookmarked and mentally filed away. Although I usually write Python scripts instead, I look forward to breaking this out some time.</p>","replies":[]}]